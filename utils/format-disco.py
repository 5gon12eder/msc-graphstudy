#! /usr/bin/python3
#! -*- coding:utf-8; mode:python; -*-

# Copyright (C) 2018 Moritz Klammler <moritz.klammler@student.kit.edu>
#
# Copying and distribution of this file, with or without modification, are permitted in any medium without royalty
# provided the copyright notice and this notice are preserved.  This file is offered as-is, without any warranty.

import argparse
import collections
import contextlib
import os
import sys

from email.utils import formatdate as format_rfc5322

LAZYOK = None
LAZYOK_ENVVAR = 'MSC_LAZY_EVAL_OKAY'

DiscoRecord = collections.namedtuple('DiscoRecord', [ 'lhs', 'rhs', 'value', 'model' ])

def main():
    ap = argparse.ArgumentParser(description="Formats a discrimination results file as TeX code.")
    ap.add_argument('src', metavar='FILE', help="read from FILE")
    ap.add_argument('-o', '--output', metavar='FILE', type=argparse.FileType('w'), help="write to FILE")
    ap.add_argument(
        '-n', '--name', metavar='MODEL=NAME', dest='dmnames', action='append', type=parse_dmnamespec,
        help="use TeX name NAME for discriminator model MODEL (can be repeated)"
    )
    ap.add_argument('--print-names', action='store_true', help="print discriminator model names and exit")
    ns = ap.parse_args()
    dmnames = { dm : ''.join(filter(str.isalnum, dm.name.lower())) for dm in const.Tests }
    if ns.dmnames is not None:
        dmnames.update(ns.dmnames)
    if ns.print_names:
        for dm in sorted(dmnames.keys()):
            print(dm.name, dmnames[dm])
        raise SystemExit()
    try:
        with open(ns.src, 'r') if ns.src != '-' else contextlib.nullcontext(sys.stdin) as istr:
            disco = list(parse_disco_file(istr))
    except FileNotFoundError:
        check_lazy_okay(ns.src)
        disco = None
    shortid = lambda id : str(id)[:8]
    dmname = lambda dm : dmnames[dm]
    scriptname = os.path.basename(__file__)
    timestamp = format_rfc5322(localtime=True)
    with contextlib.redirect_stdout(ns.output) if ns.output is not None else contextlib.nullcontext():
        print("% -*- coding:utf-8; mode:latex; -*-")
        print("")
        print("%% THIS IS A GENERATED FILE; PLEASE DO NOT EDIT IT MANUALLY!")
        print("%% Generated by {!r} on {!s}".format(scriptname, timestamp))
        print("")
        if disco is None:
            print("% This file contains no records (note: {!s}={!r}).".format(LAZYOK_ENVVAR, 1))
            return
        print("% This file contains {:,d} records.".format(len(disco)))
        for record in disco:
            print("")
            print("% lhsid: {!s}".format(record.lhs))
            print("% rhsid: {!s}".format(record.rhs))
            print("% value: {:+.10f}".format(record.value))
            print("% model: {:s}".format(record.model.name))
            print(r"\expandafter\def\csname msc@{lhs:s}-{rhs:s}@{dm:s}\endcsname{{{p:.3f}}}".format(
                lhs=shortid(record.lhs), rhs=shortid(record.rhs), p=(100.0 * record.value), dm=dmname(record.model)
            ))

def parse_disco_file(istr):
    records = list()
    for (i, line) in enumerate(map(lambda s : s.partition('#')[0].strip(), istr), start=1):
        if not line: continue
        def fail(*args, **kwargs):
            bemoan('{:s}:{:d}'.format(istr.name, i), *args, **kwargs, fatal=True)
        try:
            [ lhsid, rhsid, p, dm ] = line.split()
        except ValueError:
            fail("Expected exactly 4 tokens on line", repr(line))
        try: lhsid = const.Id(lhsid)
        except ValueError: fail("Cannot parse layout ID", repr(lhsid))
        try: rhsid = const.Id(rhsid)
        except ValueError: fail("Cannot parse layout ID", repr(rhsid))
        try: p = float(p)
        except ValueError: fail("Cannot parse floating-point number", repr(p))
        try: dm = const.enum_from_json(const.Tests, dm)
        except ValueError: fail("Cannot parse discriminator model specification", repr(dm))
        yield DiscoRecord(lhs=lhsid, rhs=rhsid, value=p, model=dm)

def parse_dmnamespec(text):
    if text.count('=') != 1:
        raise argparse.ArgumentTypeError("not in MODEL=NAME format")
    (enumname, colon, texname) = text.partition('=')
    try:
        dm = const.enum_from_json(const.Tests, enumname)
    except ValueError as e:
        raise argparse.ArgumentTypeError(e)
    return (dm, texname.strip())

def check_lazy_okay(filename=None):
    if not LAZYOK:
        if filename is not None:
            bemoan("No such file or directory", filename)
        bemoan("Cannot continue due to missing discrimination data (set {!s}={!r} to continue anyway)"
               .format(LAZYOK_ENVVAR, 1), fatal=True)

def get_lazy_okay():
    assert LAZYOK is None
    envval = os.getenv(LAZYOK_ENVVAR, 0)
    try:
        return int(envval) > 0
    except ValueError:
        bemoan(LAZYOK_ENVVAR, "Not a valid integer", repr(envval))
        return False

def bemoan(*msg, fatal=False):
    script = os.path.basename(__file__)
    print(script, *msg, sep=": ", file=sys.stderr)
    if fatal: raise SystemExit(True)

if __name__ == '__main__':
    if os.path.exists('.msc-graphstudy'):
        sys.path.append(os.getcwd())
    import driver.constants as const
    LAZYOK = get_lazy_okay()
    main()
