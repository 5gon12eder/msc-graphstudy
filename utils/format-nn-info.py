#! /usr/bin/python3
#! -*- coding:utf-8; mode:python; -*-

# Copyright (C) 2018 Moritz Klammler <moritz.klammler@student.kit.edu>
#
# Copying and distribution of this file, with or without modification, are permitted in any medium without royalty
# provided the copyright notice and this notice are preserved.  This file is offered as-is, without any warranty.

import argparse
import collections
import json
import os
import re
import sys

from email.utils import formatdate as format_rfc5322

def main():
    ap = argparse.ArgumentParser(description="Format neural network information as TeX code.")
    ap.add_argument('-o', '--output', metavar='FILE', type=argparse.FileType('w'), help="write to FILE")
    ap.add_argument('--shared-info', metavar='FILE', type=argparse.FileType('r'), required=True,
                    help="read information about the shared model from FILE (Keras debug output)")
    ap.add_argument('--total-info', metavar='FILE', type=argparse.FileType('r'), required=True,
                    help="read information about the total model from FILE (Keras debug output)")
    ap.add_argument('--corpus', metavar='FILE', type=argparse.FileType('r'), required=True,
                    help="read data corpus summary from JSON FILE")
    ns = ap.parse_args()
    (shared_layers, shared_info) = Parser(ns.shared_info)()
    (total_layers, total_info) = Parser(ns.total_info)()
    corpus = json.load(ns.corpus)
    scriptname = os.path.basename(__file__)
    timestamp = format_rfc5322(localtime=True)
    print("% -*- coding:utf-8; mode:latex; -*-", file=ns.output)
    print("", file=ns.output)
    print("%% THIS IS A GENERATED FILE; PLEASE DO NOT EDIT IT MANUALLY!", file=ns.output)
    print("%% Generated by {!r} on {!s}".format(scriptname, timestamp), file=ns.output)
    print("", file=ns.output)
    fmtint = lambda n : format(n, ',d').replace(',', '\\,')
    print(get_layer_dim_def('NNSharedInputDims',    shared_layers, 'in',    'InputLayer'  ), file=ns.output)
    print(get_layer_dim_def('NNSharedHiddenDims',   shared_layers, 'l1',    'Dense'       ), file=ns.output)
    print(get_layer_dim_def('NNSharedOutputDims',   shared_layers, 'l2',    'Dense'       ), file=ns.output)
    print(get_layer_dim_def('NNTotalAuxInputDims',  total_layers,  'auxin', 'InputLayer'  ), file=ns.output)
    print(get_layer_dim_def('NNTotalAuxHiddenDims', total_layers,  'aux',   'Dense'       ), file=ns.output)
    print(get_layer_dim_def('NNTotalCatDims',       total_layers,  'cat',   'Concatenate' ), file=ns.output)
    print(get_layer_dim_def('NNTotalOutputDims',    total_layers,  'out',   'Dense'       ), file=ns.output)
    print(r"\def\NNTotalTrainableParams{" + fmtint(total_info['trainable-params']) + r"}", file=ns.output)
    print(r"\def\NNCorpusSize{" + fmtint(corpus['size']) + r"}", file=ns.output)
    print(r"\def\NNCorpusSizeApprox{" + fmtint(1000 * round(corpus['size'] / 1000)) + r"}", file=ns.output)

def get_layer_dim_def(csname, layerinfos, name, type=None):
    info = layerinfos[name]
    assert type is None or info.type == type
    return '\\def\\' + csname + '{' + str(info.dims) + '}'

LayerInfo = collections.namedtuple('LayerInfo', [ 'type', 'dims', 'params' ])
LineInfo = collections.namedtuple('LineInfo', [ 'number', 'text' ])

class Parser(object):

    _LAYER_INFO_PATTERN = re.compile(
        r'(?P<name>\w+)\s+\((?P<type>\w+)\)\s+\(\s*None\s*,\s*(?P<dims>\d+)\)\s+(?P<params>\d+)'
    )

    def __init__(self, istr):
        self.__filename = istr.name
        self.__lines = [ LineInfo(i, l) for (i, l) in enumerate(map(str.strip, istr), start=1) if l ]
        self.__width = None
        self.__i = 0
        self.__layer_info = dict()
        self.__network_info = dict()

    def __call__(self):
        assert self.__i == 0
        print("Parsing info file {!r} ...".format(self.__filename), file=sys.stderr)
        self.__width = self.__get_hrule_width()
        self.__expect_hrule('_')
        self.__expect_column_headers()
        self.__expect_hrule('=')
        while True:
            if not self.__parse_layer_info():
                self.__complain("Expected network layer information")
            while not self.__is_hrule(self.__current_line()):
                self.__next_line()
            if self.__is_hrule(self.__current_line(), char='='):
                break
            self.__expect_hrule(char='_', advance=False)
        while self.__parse_network_info():
            pass
        self.__expect_hrule(char='_', advance=False)
        if self.__next_line(eof=True) is not None:
            self.__complain("Expected end of file")
        return self.__layer_info, self.__network_info

    def __parse_layer_info(self):
        m = self.__class__._LAYER_INFO_PATTERN.match(self.__next_line().text)
        if m is None: return False
        self.__layer_info[m.group('name')] = LayerInfo(
            type=m.group('type'), dims=int(m.group('dims')), params=int(m.group('params'))
        )
        return True

    def __parse_network_info(self):
        (key, sep, val) = self.__next_line().text.partition(':')
        if sep != ':': return False
        key = '-'.join(key.lower().split())
        val = int(val.replace(',', ''))
        self.__network_info[key] = val
        return True

    def __expect_column_headers(self):
        line = self.__next_line()
        expected_headers = [ "LAYER (TYPE)", "OUTPUT SHAPE", "PARAM #", "CONNECTED TO" ]
        actual_headers = list(filter(None, map(str.strip, line.text.upper().split("  "))))
        if actual_headers != expected_headers[:max(3, len(actual_headers))]:
            self.__complain("Expected column headers not found")

    def __get_hrule_width(self):
        widths = { len(l.text) for l in self.__lines if all(not c.isalnum() for c in l.text) }
        if len(widths) != 1:
            self.__complain("No consistent horizontal separator lines found")
        return next(iter(widths))

    def __is_hrule(self, line, char=None):
        if len(line.text) != self.__width:
            return False
        elif char is None:
            return all(not c.isalnum() for c in line.text)
        else:
            return all(c == char for c in line.text)

    def __expect_hrule(self, char=None, advance=True):
        if not self.__is_hrule(self.__next_line() if advance else self.__current_line(), char=char):
            if char is None:
                self.__complain("Expected a horizontal rule of {:d} characters".format(self.__width))
            else:
                self.__complain("Expected a horizontal rule of {:d} {!r} characters".format(self.__width, char))

    def __current_line(self):
        try: return self.__lines[self.__i - 1]
        except IndexError: return None

    def __next_line(self, eof=False):
        self.__i += 1
        try:
            return self.__lines[self.__i - 1]
        except IndexError:
            pass
        if not eof:
            self.__complain("Unexpected end of file")

    def __complain(self, reason, fatal=True):
        where = self.__filename
        if self.__i > 0:
            try:               lineno = self.__lines[self.__i - 1].number
            except IndexError: lineno = self.__lines[-1].number
            where += ':' + str(lineno)
        print(where, reason, sep=': ', file=sys.stderr)
        if fatal: raise SystemExit(True)

if __name__ == '__main__':
    main()
